# 复合类型
>- 计算机程序在存储数据时候必须跟踪的3个基本属性：  
> 存储位置  
> 存储值大小  
> 存储信息类型  
## 字符串
>> 字符串和字符数组不一样
```c++
    char dog[6] = {'d', 'e', 'u',' ', 'v', 'p'};//字符数组
    char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'}; //字符串 char cat[8] = "fatessa";
    注意 ‘\0’ 的位置
```
>>- 在确定存储字符所需的最短数组时，要将结尾的空字符计算在内。  
>>- 输入 cin 的方法 get() & getline() 有失效位（failbit）
----
## string 类 （位于std名称空间中）
>- char 数组视为一组存储一个字符串的 char 存储单元；  
>- string 类变量是一个表示字符串的实体。  
---
>>>- 访问类成员函数的方式是从访问结构体成员变量的方式衍生而来的
---
## 结构
>>- c++不提倡使用外部变量，但提倡使用外部结构声明  
>>- 与数组一样，C++11支持将列表初始化用于结构，且等号（=）是可选的。
>> 不允许缩窄转换
## 共用体
>>- 共用体能存不同类型的数据，但只能同时存其中的一种类型。共用体长度为其最大的成员长度。  
>>- 用途：当数据项使用两种或是多种格式（但不会同时使用），可以节省空间
# 指针与C++基本原理
>- OOP 强调的是在运行阶段（而不是在编译阶段）进行决策。  
>- 如在分配内存时候会使用关键字 new 请求正确数量内存以及使用指针来跟踪新内存的位置。  
>- 指针用于存储值的地址，地址视为指定量，而将值视为派生量。指针名表示地址，*运算符称为解引用，应用于指针得到该地址处的值。  
>- 每个指针变量名都需要使用一个 * 来声明创建:
> ```c++
>    int* p1, * p2;
> ```
>- 在c++创建指针的时，计算机将分配用来存储地址的内存，而不是分配用来存储指针所指向的数据的内存。数据提供一个空间
>>- 指针-->在运行阶段分配未命名的内存以存储值。
> ```c++
>   int* pn = new int;
>   // 为一个数据对象获得并指定分配内存的通用格式：
>   // typeName* pointer_name = new typeName;
>
>   // new（堆） 运算符根据类型来确定需要多少字节的内存，并找到对应的内存，然后返回其地址 
>  // pn 指向一个数据对象（数据对象是为数据项分配的内存块）
> //new 和 delete 配对；
> ```
# 字符串
>>- 如果要显示字符串的地址，则必须将（char*）这种指针强制转换为另一种指针类型(int*)。
# 二级指针
>- 参数传递要想函数结束之后指针依然有效，就必须在函数内部改动外部指针的地址，而不是它指向的数据，因为参数传递会拷贝一份新的，只有数据一样，而它两的地址是不一样的。  
>- 内部改动之后不会对外部产生任何影响，所以需要用到二级指针**p，*p = &q,这样就可以进行指针转向了。
>- 对于一级指针（int* p）有三层结构，二级指针(int** p)有四级结构
>>  | int* p | int** p| |
>>  |:---:|:---:|:---|
>>  | *p |**p| 4|
>>  |p |*p|3|
>>  |&p|p|2|
>>  ||&p|1|

>> 对于二级指针来说，获取顶层数值:  
>>- 可以通过操作 2 再用 ** 获取
>>- 也可以通过操作 3 再用 * 获取