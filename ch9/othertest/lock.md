# lock

## 死锁
> 1. 忘记解锁
> 2. 条件判断退出时候忘记解锁
> 3. 重复加锁，临界区内调用其他函数，该函数里面也存在临界区，造成重复加锁
> 4. 多个临界区相互访问造成死锁
## 解决方法
> 1. 多检查
> 2. 使用 trylock() 函数
> 3. 程序中有多把锁，控制对锁的顺序访问，但有些情况不行。（访问其他临界区的时候把自己的锁解开）
> 4. 引入专门用于检测死锁的检测模块

## 读写锁 （pthread_rwlock_t）
>> 一把锁 (读时共享，写时互斥)
> 1. 